<!DOCTYPE html><html><head><!-- Created with tagspaces 2.6.0 --><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><style type='text/css'>body{overflow:auto;width:100%;height:100%;font:13.34px Ubuntu,arial,clean,sans-serif;color:#000;line-height:1.4em;background-color:#fff;padding:15px}p{margin:1em 0;line-height:1.5em}table{font:100%;margin:1em}table th{border-bottom:1px solid #bbb;padding:.2em 1em}table td{border-bottom:1px solid #ddd;padding:.2em 1em}input[type=image],input[type=password],input[type=text],textarea{font:99% helvetica,arial,freesans,sans-serif}option,select{padding:0 .25em}optgroup{margin-top:.5em}code,pre{font:12px Monaco,'Courier New','DejaVu Sans Mono','Bitstream Vera Sans Mono',monospace}pre{margin:1em 0;font-size:12px;background-color:#eee;border:1px solid #ddd;padding:5px;line-height:1.5em;color:#444;overflow:auto;-webkit-box-shadow:rgba(0,0,0,.07) 0 1px 2px inset;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}pre code{padding:0;font-size:12px;background-color:#eee;border:none}code{font-size:12px;background-color:#f8f8ff;color:#444;padding:0 .2em;border:1px solid #dedede}img{border:0;max-width:100%}abbr{border-bottom:none}a{color:#4183c4;text-decoration:none}a:hover{text-decoration:underline}a code,a:link code,a:visited code{color:#4183c4}h2,h3{margin:1em 0}h1,h2,h3,h4,h5,h6{border:0}h1{font-size:170%;border-top:4px solid #aaa;padding-top:.5em;margin-top:1.5em}h1:first-child{margin-top:0;padding-top:.25em;border-top:none}h2{font-size:150%;margin-top:1.5em;border-top:4px solid #e0e0e0;padding-top:.5em}h3{font-size:130%;margin-top:1em}h4{font-size:120%;margin-top:1em}h5{font-size:115%;margin-top:1em}h6{font-size:110%;margin-top:1em}hr{border:1px solid #ddd}ol,ul{margin:1em 0 1em 2em}ol li,ul li{margin-top:.5em;margin-bottom:.5em}ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}blockquote{margin:1em 0;border-left:5px solid #ddd;padding-left:.6em;color:#555}dt{font-weight:700;margin-left:1em}dd{margin-left:2em;margin-bottom:1em}</style></head><body data-sourceurl='' data-scrappedon='' ><h2 style="margin: 0px 0px 4px; font-size: 20px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; letter-spacing: normal;"><a id="cb_post_title_url" href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html" style="color: rgb(34, 51, 85);">短路径—Dijkstra算法和Floyd算法</a></h2><div class="postbody" style="font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; letter-spacing: normal;"><div id="cnblogs_post_body" style="margin-bottom: 20px; word-break: break-word;"><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;"><span style="font-size: 18pt;"><strong><span style="color: rgb(0, 0, 128);">注意：以下代码 只是描述思路，没有测试过！！</span></strong></span></p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;"><span style="font-size: 15px;"><strong><span style="color: rgb(0, 0, 128);">Dijkstra算法</span></strong></span></p><p style="margin: 10px auto;">1.定义概览</p><p style="margin: 10px auto;">Dijkstra(迪杰斯特拉)算法是典型的<span style="color: rgb(0, 0, 255);">单源最短路径算法</span>，用于计算一个节点到其他所有节点的最短路径。主要特点是<span style="color: rgb(0, 0, 255);">以起始点为中心向外层层扩展，直到扩展到终点为止</span>。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。</p><p style="margin: 10px auto;">问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）</p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">2.算法描述</p><p style="margin: 10px auto;">1)算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，<span style="color: rgb(0, 0, 255);">第一组为已求出最短路径的顶点集合</span>（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），<span style="color: rgb(0, 0, 255);">第二组为其余未确定最短路径的顶点集合（用U表示），</span>按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从<span style="color: rgb(0, 0, 255);">源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度</span>。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><p style="margin: 10px auto;">2)算法步骤：</p><p style="margin: 10px auto 10px 30px;">a.初始时，<span style="color: rgb(0, 0, 255);">S只包含源点</span>，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。</p><p style="margin: 10px auto 10px 30px;">b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</p><p style="margin: 10px auto 10px 30px;">c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</p><p style="margin: 10px auto 10px 30px;">d.重复步骤b和c直到所有顶点都包含在S中。</p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">执行动画过程如下图</p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073019540660.gif" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">3.算法代码实现：</p><p style="margin: 10px auto;">&nbsp;</p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); background-color: rgb(245, 245, 245) !important; border: none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width: 900px; border-width: initial !important; border-style: none !important;"></a></span></div><pre style="margin-bottom: 0px; margin-left: 22px; white-space: pre-wrap; font-family: &quot;Courier New&quot; !important;"><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">const</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span>  MAXINT = <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">32767</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">;
</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">const</span> <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> MAXNUM = <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">10</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">;
</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> dist[MAXNUM];
</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> prev[MAXNUM];

</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> A[MAXUNM][MAXNUM];

</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span> Dijkstra(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> v0)
{
  　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">bool</span> S[MAXNUM];                                  <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;"> 判断是否已存入该点到S集合中</span>
      <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> n=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">MAXNUM;
  　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> i=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">1</span>; i&lt;=n; ++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">i)
 　　 {
      　　dist[i] </span>=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> A[v0][i];
      　　S[i] </span>= <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">false</span>;                                <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;"> 初始都未用过该点</span>
      　　<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span>(dist[i] ==<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> MAXINT)    
            　　prev[i] </span>= -<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">1</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">;
 　　     </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">else</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> 
            　　prev[i] </span>=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> v0;
   　　}
   　 dist[v0] </span>= <span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">;
   　 S[v0] </span>= <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">true</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">; 　　
 　　 </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> i=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">2</span>; i&lt;=n; i++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
 　　 {
       　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> mindist =<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> MAXINT;
       　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> u = v0; 　　                            <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;"> 找出当前未使用的点j的dist[j]最小值</span>
      　　 <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> j=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">1</span>; j&lt;=n; ++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">j)
      　　    </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span>((!S[j]) &amp;&amp; dist[j]&lt;<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">mindist)
      　　    {
         　　       u </span>= j;                             <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;"> u保存当前邻接点中距离最小的点的号码 </span>
         　 　      mindist =<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> dist[j];
       　　   }
       　　S[u] </span>= <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">true</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">; 
       　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(<span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> j=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">1</span>; j&lt;=n; j++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
       　　    </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span>((!S[j]) &amp;&amp; A[u][j]&lt;<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">MAXINT)
       　　    {
           　    　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span>(dist[u] + A[u][j] &lt; dist[j])     <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">在通过新加入的u点路径找到离v0点更短的路径  </span>
<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">           　    　{
                   　　dist[j] </span>= dist[u] + A[u][j];    <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">更新dist </span>
                   　　prev[j] = u;                    <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">记录前驱顶点 </span>
<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">            　　    }
        　    　}
   　　}
}</span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); background-color: rgb(245, 245, 245) !important; border: none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width: 900px; border-width: initial !important; border-style: none !important;"></a></span></div></div><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">4.算法实例</p><p style="margin: 10px auto;">先给出一个无向图</p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073019593375.jpg" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;">用Dijkstra算法找出以A为起点的单源最短路径步骤如下</p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073020014941.jpg" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;"><span style="font-size: 15px;"><strong><span style="color: rgb(0, 0, 128);">Floyd算法</span></strong></span></p><p style="margin: 10px auto;">1.定义概览</p><p style="margin: 10px auto;"><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N<sup>3</sup>)，空间复杂度为O(N<sup>2</sup>)。</p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">2.算法描述</p><p style="margin: 10px auto;">1)算法思想原理：</p><p style="margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 255);">Floyd算法是一个经典的动态规划算法</span>。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p><p style="margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们<span style="color: rgb(0, 0, 255);">检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立</span>，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们<span style="color: rgb(0, 0, 255);">便设置Dis(i,j) = Dis(i,k) + Dis(k,j</span>)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p><p style="margin: 10px auto;">2).算法描述：</p><p style="margin: 10px auto 10px 30px;">a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　</p><p style="margin: 10px auto 10px 30px;">b.对于<span style="color: rgb(0, 0, 255);">每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短</span>。如果是更新它。</p><p style="margin: 10px auto;">3).<span class="link_title">Floyd算法过程矩阵的计算----十字交叉法</span></p><p style="margin: 10px auto;"><span class="link_title">方法：两条线，从左上角开始计算一直到右下角 如下所示</span></p><p style="margin: 10px auto;"><span class="link_title">给出矩阵，其中矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点</span></p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073109403649.gif" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;">相应计算方法如下：</p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073109460084.jpg" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073109453085.jpg" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;"><img src="http://pic002.cnblogs.com/images/2012/426620/2012073109463549.jpg" alt="" style="max-width: 900px; margin-right: auto; margin-left: auto; display: block;"></p><p style="margin: 10px auto;">最后A<sub>3</sub>即为所求结果</p><p style="margin: 10px auto;">&nbsp;</p><p style="margin: 10px auto;">3.算法代码实现</p><div class="cnblogs_code" style="background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); padding: 5px; overflow: auto; margin: 5px 0px; font-family: &quot;Courier New&quot; !important; font-size: 12px !important;"><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); background-color: rgb(245, 245, 245) !important; border: none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width: 900px; border-width: initial !important; border-style: none !important;"></a></span></div><pre style="margin-bottom: 0px; margin-left: 22px; white-space: pre-wrap; font-family: &quot;Courier New&quot; !important;">typedef <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">struct</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">          
{        
    </span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">char</span> vertex[VertexNum];                                <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">顶点表         </span>
    <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> edges[VertexNum][VertexNum];                       <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">邻接矩阵,可看做边表         </span>
    <span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> n,e;                                               <span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">//</span><span style="color: rgb(0, 128, 0); line-height: 1.5 !important;">图中当前的顶点数和边数         </span>
<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">}MGraph; 
<br></span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">void</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> Floyd(MGraph g)
{
 　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> A[MAXV][MAXV];
 　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;"> path[MAXV][MAXV];
 　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">int</span> i,j,k,n=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">g.n;
 　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(i=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span>;i&lt;n;i++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
    　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(j=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span>;j&lt;n;j++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
    　　{ 　　
             A[i][j]</span>=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">g.edges[i][j];
         　　 path[i][j]</span>=-<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">1</span><span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">;
     　 }
 　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(k=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span>;k&lt;n;k++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
 　　{ 
      　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(i=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span>;i&lt;n;i++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
         　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">for</span>(j=<span style="color: rgb(128, 0, 128); line-height: 1.5 !important;">0</span>;j&lt;n;j++<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">)
             　　</span><span style="color: rgb(0, 0, 255); line-height: 1.5 !important;">if</span>(A[i][j]&gt;(A[i][k]+<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">A[k][j]))
             　　{<br>                   　　A[i][j]</span>=A[i][k]+<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">A[k][j];
                   　　path[i][j]</span>=<span style="color: rgb(0, 0, 0); line-height: 1.5 !important;">k;
              　 } 
    　} <br>} </span></pre><div class="cnblogs_code_toolbar" style="margin-top: 5px;"><span class="cnblogs_code_copy" style="padding-right: 5px; line-height: 1.5 !important;"><a title="复制代码" style="color: rgb(29, 88, 209); background-color: rgb(245, 245, 245) !important; border: none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width: 900px; border-width: initial !important; border-style: none !important;"></a></span></div></div></div></div></body></html>