<!DOCTYPE html><html><head><!-- Created with tagspaces 2.6.0 --><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><style type='text/css'>body{overflow:auto;width:100%;height:100%;font:13.34px Ubuntu,arial,clean,sans-serif;color:#000;line-height:1.4em;background-color:#fff;padding:15px}p{margin:1em 0;line-height:1.5em}table{font:100%;margin:1em}table th{border-bottom:1px solid #bbb;padding:.2em 1em}table td{border-bottom:1px solid #ddd;padding:.2em 1em}input[type=image],input[type=password],input[type=text],textarea{font:99% helvetica,arial,freesans,sans-serif}option,select{padding:0 .25em}optgroup{margin-top:.5em}code,pre{font:12px Monaco,'Courier New','DejaVu Sans Mono','Bitstream Vera Sans Mono',monospace}pre{margin:1em 0;font-size:12px;background-color:#eee;border:1px solid #ddd;padding:5px;line-height:1.5em;color:#444;overflow:auto;-webkit-box-shadow:rgba(0,0,0,.07) 0 1px 2px inset;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}pre code{padding:0;font-size:12px;background-color:#eee;border:none}code{font-size:12px;background-color:#f8f8ff;color:#444;padding:0 .2em;border:1px solid #dedede}img{border:0;max-width:100%}abbr{border-bottom:none}a{color:#4183c4;text-decoration:none}a:hover{text-decoration:underline}a code,a:link code,a:visited code{color:#4183c4}h2,h3{margin:1em 0}h1,h2,h3,h4,h5,h6{border:0}h1{font-size:170%;border-top:4px solid #aaa;padding-top:.5em;margin-top:1.5em}h1:first-child{margin-top:0;padding-top:.25em;border-top:none}h2{font-size:150%;margin-top:1.5em;border-top:4px solid #e0e0e0;padding-top:.5em}h3{font-size:130%;margin-top:1em}h4{font-size:120%;margin-top:1em}h5{font-size:115%;margin-top:1em}h6{font-size:110%;margin-top:1em}hr{border:1px solid #ddd}ol,ul{margin:1em 0 1em 2em}ol li,ul li{margin-top:.5em;margin-bottom:.5em}ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}blockquote{margin:1em 0;border-left:5px solid #ddd;padding-left:.6em;color:#555}dt{font-weight:700;margin-left:1em}dd{margin-left:2em;margin-bottom:1em}</style></head><body data-sourceurl='' data-scrappedon='' ><header style="color: rgb(66, 66, 66); font-family: Helvetica, Arial, sans-serif; font-size: 14px; letter-spacing: normal;"><h1 style="padding: 0px; font-size: 34px; line-height: 1.35; letter-spacing: -0.02em; margin-top: 24px; margin-bottom: 0px; font-family: Roboto, Helvetica, Arial, sans-serif;">Using DFA for Wildcard Matching Problem</h1><div class="categories" style="color: rgb(130, 130, 130); margin-bottom: 10px;">Posted in:&nbsp;<ul class="categories-list" style="letter-spacing: 0px; line-height: 24px; display: inline-block; list-style-type: none; padding: 0px;"><li style="display: inline-block; padding-right: 3px;"><a href="http://wpc.github.io/#algorithm-ref" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(130, 130, 130);">algorithm</a></li></ul></div></header><article style="color: rgb(66, 66, 66); font-family: Helvetica, Arial, sans-serif; font-size: 14px; letter-spacing: normal;"><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Wildcard matching has a very simple matching language: use “?” to match any single character and “*” for matching any text (include empty). It is not as powerful as regular expression, but on the other side it is much more understandable for the end user. Some examples:</p><table style="min-width: 60%; border: 1px solid rgb(204, 204, 204); background-color: rgb(251, 251, 251); padding: 15px; table-layout: fixed;"><thead><tr><th>text</th><th>pattern</th><th>matchs</th></tr></thead><tbody><tr><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">a</td><td style="word-wrap: break-word;">no</td></tr><tr><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">yes</td></tr><tr><td style="word-wrap: break-word;">aaa</td><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">no</td></tr><tr><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">*</td><td style="word-wrap: break-word;">yes</td></tr><tr><td style="word-wrap: break-word;">aa</td><td style="word-wrap: break-word;">a*</td><td style="word-wrap: break-word;">yes</td></tr><tr><td style="word-wrap: break-word;">ab</td><td style="word-wrap: break-word;">?*</td><td style="word-wrap: break-word;">yes</td></tr><tr><td style="word-wrap: break-word;">aab</td><td style="word-wrap: break-word;"><code class="highlighter-rouge">c*a*b</code></td><td style="word-wrap: break-word;">yes</td></tr></tbody></table><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Recently I need implement it for one of my side project. In the project most user search goes through lucene index query NEO4j embedded when doing a wildcard match. But in some cases when user’s search cannot directly map to a index, I need go through large amount of strings to find matches.</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">It is a interesting algorithm problem not as simple as it looked like. Because&nbsp;<code class="highlighter-rouge">"*"</code>&nbsp;match needs greedily look forward. For example, in the case of “abcbc” matching pattern “a*bc”, the algorithm need backtrack to&nbsp;<code class="highlighter-rouge">"*"</code>&nbsp;to restart matching when it found “abcb” do not match “a*bc”.</p><h1 id="start-with-a-naive-implementation" style="padding: 0px; font-size: 30px; line-height: 1.35; letter-spacing: -0.02em; margin-top: 24px; margin-bottom: 24px; font-family: Roboto, Helvetica, Arial, sans-serif;">Start with a naive implementation</h1><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">I happened to solve this problem on&nbsp;<a href="https://leetcode.com/problems/wildcard-matching/" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">leetcode</a>&nbsp;long time ago. At the time I wrote a naive implementation based on recursive backtracking. Once encounter a&nbsp;<code class="highlighter-rouge">"*"</code>, the algorithm scan from back of the text, and try recursively find a match for rest of the patten. This algorithm can handle greedy cases like&nbsp;<code class="highlighter-rouge">(“abcbb”, “a*bc”)</code>&nbsp;correctly, but yield very high time complexity. If text length is&nbsp;<strong>n</strong>, and pattern length is&nbsp;<strong>m</strong>, the worst case complexity is&nbsp;<strong>O(n!<code class="highlighter-rouge">*</code>m)</strong>. So the algorithm never finish when text is long and pattern has a lot of stars, such as:</p><figure class="highlight" style="background: rgb(243, 243, 243); padding: 3px 15px; border-radius: 5px;"><pre><code class="language-yaml" data-lang="yaml"><span class="s" style="color: rgb(221, 17, 68);">pattern</span><span class="pi">:</span> <span class="s2" style="color: rgb(221, 17, 68);">"</span><span class="s" style="color: rgb(221, 17, 68);">a*b*a*b*aaaa*abaaa**b*a***b*a*bb****ba*ba*b******a********a**baba*ab***a***bbba*b**a*b*ba*a*aaaa*ab"</span>
<span class="s" style="color: rgb(221, 17, 68);">text</span><span class="pi">:</span> <span class="s2" style="color: rgb(221, 17, 68);">"</span><span class="s" style="color: rgb(221, 17, 68);">aabbbbaababbabababaabbbbabbabbaabbbabbbabaabbaaaababababbababbabbbbabaaabaaabaabbaaaabbbbabaaabbbbbabbbaabbbbbabaabababaaabaaababaababbaaabaabbabaababbabababaaababbabbabaabbbbabbbbabaabbaababaaabababbab"</span></code></pre></figure><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">At the time I ended up with putting a cache for failures matches. It helped shortcut the factorial part and reduce the worst case complexity to&nbsp;<strong>O(n<code class="highlighter-rouge">*</code>m)</strong>. Good enough for me to move on.</p><h1 id="lucenes-implementation" style="padding: 0px; font-size: 30px; line-height: 1.35; letter-spacing: -0.02em; margin-top: 24px; margin-bottom: 24px; font-family: Roboto, Helvetica, Arial, sans-serif;">Lucene’s implementation</h1><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">But this obviously is not good enough for production code. I was wondering what is Lucene’s implementation looked like. So I download source code of Lucene 3.6.2. (v3.6.2 is the version of Lucene that Neo4j embedded). I was shockingly surprised the implementation is almost identical to my first naive implementation. It does not even have the failure caches so it is a straight worst case&nbsp;<strong>O(n!<code class="highlighter-rouge">*</code>m)</strong>&nbsp;algorithm. I guess this means if you find some server software using Lucene 3 and you can make a wildcard query, you can easily DOS it using previous mentioned cases.</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">(I have already check latest version of Lucene. Turns out from version 4.0, Lucene switched to a DFA solution. So there is no need to race for a pull request :-).</p><h1 id="solution-based-on-dfa" style="padding: 0px; font-size: 30px; line-height: 1.35; letter-spacing: -0.02em; margin-top: 24px; margin-bottom: 24px; font-family: Roboto, Helvetica, Arial, sans-serif;">Solution based on DFA</h1><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">This problem is somehow similar with classic “find needle in the hay”&nbsp;<a href="https://en.wikipedia.org/wiki/String_searching_algorithm" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">string searching problem</a>. For that we have the famous&nbsp;<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">KMP algorithm</a>. KMP is inspiring on how it compiles the pattern into a lookup table to so that it only need go through the text string once without backtracking. In our cases, because we need go though large amount of strings, it will be really beneficial if we can compile pattern to some kind of structure helping us scan the text only once. It will make the worst time complexity of each match to&nbsp;<strong>O(n)</strong>.</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">The most straight forward helpful structure we can compile to is a&nbsp;<a href="https://en.wikipedia.org/wiki/Finite-state_machine" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">FSM (Finite-state machine)</a>. More specificly a&nbsp;<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">DFA (Deterministic finite state machine)</a>. With it we can present each matching situations via states, from each state we can use transitions tells which state it should switch to base on the current character read. For example, we can present the pattern&nbsp;<strong><code class="highlighter-rouge">a*bc</code></strong>&nbsp;as following state machine:</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;"><img src="http://wpc.github.io/assets/screenshots/dfa.jpg" alt="screenshot">&nbsp;￼ In this state machine,&nbsp;<strong>s0</strong>&nbsp;is initial state presenting match no input. State&nbsp;<strong>s3</strong>&nbsp;is the accepting state (denoted by double circle). The matching process become: start from&nbsp;<strong>s0</strong>, base on the input character following the corresponding transition transit to the next state. Keep doing this until there is no transition to go (dead end return not match), or reaching the end of the text. In later case return “match” if the machine stops at a acceptable state (<strong>s3</strong>&nbsp;in our case) otherwise “no match”.</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Here is an example:</p><figure class="highlight" style="background: rgb(243, 243, 243); padding: 3px 15px; border-radius: 5px;"><pre><code class="language-yaml" data-lang="yaml"><span class="s" style="color: rgb(221, 17, 68);">text</span><span class="pi">:</span> <span class="s" style="color: rgb(221, 17, 68);">abcbc</span>
<span class="s" style="color: rgb(221, 17, 68);">pattern</span><span class="pi">:</span> <span class="s" style="color: rgb(221, 17, 68);">a*bc</span>
<span class="s" style="color: rgb(221, 17, 68);">read ‘a’,  s0 -&gt; s1</span>
<span class="s" style="color: rgb(221, 17, 68);">read ‘b’,  s1 -&gt; s2</span>
<span class="s" style="color: rgb(221, 17, 68);">read ‘c’,  s2 -&gt; s3</span>
<span class="s" style="color: rgb(221, 17, 68);">read ‘b’,  s3 -&gt; s2</span>
<span class="s" style="color: rgb(221, 17, 68);">read ‘c’,  s2 -&gt; s3</span>
<span class="s" style="color: rgb(221, 17, 68);">read EOF,  s3 is acceptable state, return match</span></code></pre></figure><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">You can verify it with different input yourself. It works correctly and you should be able to get a concrete feeling on how the matching works.</p><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Building this state machine is a reasonable task. But it is kind of tedious to do. Fortunately there are state machine libraries available allowing define state machine with high level declarations. The library I used is&nbsp;<a href="http://www.brics.dk/automaton/" style="-webkit-tap-highlight-color: rgba(255, 255, 255, 0); color: rgb(68, 138, 255);">dk.brics.automaton</a>. Here is the java code to create the state machine:</p><figure class="highlight" style="background: rgb(243, 243, 243); padding: 3px 15px; border-radius: 5px;"><pre><code class="language-java" data-lang="java"><span class="kd" style="font-weight: bold;">public</span> <span class="kd" style="font-weight: bold;">static</span> <span class="n">Automaton</span> <span class="nf" style="color: rgb(153, 0, 0); font-weight: bold;">toAutomaton</span><span class="p">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o" style="font-weight: bold;">)</span> <span class="o" style="font-weight: bold;">{</span>
    <span class="n">Automaton</span> <span class="n">automaton</span> <span class="o" style="font-weight: bold;">=</span> <span class="n">Automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">makeEmptyString</span><span class="o" style="font-weight: bold;">();</span>
    <span class="k" style="font-weight: bold;">for</span> <span class="o" style="font-weight: bold;">(</span><span class="kt" style="color: rgb(68, 85, 136); font-weight: bold;">int</span> <span class="n">i</span> <span class="o" style="font-weight: bold;">=</span> <span class="mi" style="color: rgb(0, 153, 153);">0</span><span class="o" style="font-weight: bold;">;</span> <span class="n">i</span> <span class="o" style="font-weight: bold;">&lt;</span> <span class="n">pattern</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">length</span><span class="o" style="font-weight: bold;">();</span> <span class="n">i</span><span class="o" style="font-weight: bold;">++)</span> <span class="o" style="font-weight: bold;">{</span>
        <span class="kt" style="color: rgb(68, 85, 136); font-weight: bold;">char</span> <span class="n">p</span> <span class="o" style="font-weight: bold;">=</span> <span class="n">pattern</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">charAt</span><span class="o" style="font-weight: bold;">(</span><span class="n">i</span><span class="o" style="font-weight: bold;">);</span>
        <span class="k" style="font-weight: bold;">switch</span> <span class="o" style="font-weight: bold;">(</span><span class="n">p</span><span class="o" style="font-weight: bold;">)</span> <span class="o" style="font-weight: bold;">{</span>
            <span class="k" style="font-weight: bold;">case</span> <span class="sc" style="color: rgb(221, 17, 68);">'*'</span><span class="o" style="font-weight: bold;">:</span>
                <span class="n">automaton</span> <span class="o" style="font-weight: bold;">=</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">concatenate</span><span class="o" style="font-weight: bold;">(</span><span class="n">Automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">makeAnyString</span><span class="o" style="font-weight: bold;">());</span>
                <span class="k" style="font-weight: bold;">break</span><span class="o" style="font-weight: bold;">;</span>
            <span class="k" style="font-weight: bold;">case</span> <span class="sc" style="color: rgb(221, 17, 68);">'?'</span><span class="o" style="font-weight: bold;">:</span>
                <span class="n">automaton</span> <span class="o" style="font-weight: bold;">=</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">concatenate</span><span class="o" style="font-weight: bold;">(</span><span class="n">Automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">makeAnyChar</span><span class="o" style="font-weight: bold;">());</span>
                <span class="k" style="font-weight: bold;">break</span><span class="o" style="font-weight: bold;">;</span>
            <span class="k" style="font-weight: bold;">default</span><span class="o" style="font-weight: bold;">:</span>
                <span class="n">automaton</span> <span class="o" style="font-weight: bold;">=</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">concatenate</span><span class="o" style="font-weight: bold;">(</span><span class="n">Automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">makeChar</span><span class="o" style="font-weight: bold;">(</span><span class="n">p</span><span class="o" style="font-weight: bold;">));</span>
       <span class="o" style="font-weight: bold;">}</span>
    <span class="o" style="font-weight: bold;">}</span>
    <span class="k" style="font-weight: bold;">return</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">;</span>
<span class="o" style="font-weight: bold;">}</span></code></pre></figure><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Java matching code using the DFA:</p><figure class="highlight" style="background: rgb(243, 243, 243); padding: 3px 15px; border-radius: 5px;"><pre><code class="language-java" data-lang="java"><span class="kd" style="font-weight: bold;">public</span> <span class="kd" style="font-weight: bold;">static</span> <span class="kt" style="color: rgb(68, 85, 136); font-weight: bold;">boolean</span> <span class="nf" style="color: rgb(153, 0, 0); font-weight: bold;">wildcardMatch</span><span class="p">(</span><span class="n">String</span> <span class="n">text</span><span class="o" style="font-weight: bold;">,</span> <span class="n">Automaton</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">)</span> <span class="o" style="font-weight: bold;">{</span><span class="err" style="color: rgb(166, 23, 23); background-color: rgb(227, 210, 210);"> </span>
    <span class="k" style="font-weight: bold;">return</span> <span class="n">automaton</span><span class="o" style="font-weight: bold;">.</span><span class="na" style="color: rgb(0, 128, 128);">run</span><span class="o" style="font-weight: bold;">(</span><span class="n">text</span><span class="o" style="font-weight: bold;">);</span><span class="err" style="color: rgb(166, 23, 23); background-color: rgb(227, 210, 210);"> </span>
<span class="o" style="font-weight: bold;">}</span></code></pre></figure><p style="padding: 0px; line-height: 24px; letter-spacing: 0px; margin-bottom: 16px;">Now we have a super simple&nbsp;<strong>O(n)</strong>&nbsp;implementation for each single matches.</p></article></body></html>